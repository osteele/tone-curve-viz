# Photo Editing Controls Technical Documentation

This document describes the technical implementation of photo editing controls in the WebGL-based photo editor.

## Overview

The photo editor implements real-time image adjustments using WebGL shaders. All adjustments are performed on the GPU, allowing for efficient processing of high-resolution images.

## Light Controls

### Exposure
- Range: [-5, +5] EV (Exposure Value)
- Implementation: $RGB_{out} = RGB_{in} \times 2^{exposure}$
- Effect: Multiplicative adjustment of pixel brightness

### Contrast
- Range: [-100, +100]
- Implementation: $RGB_{out} = (RGB_{in} - 0.5) \times (1 + contrast \times 0.02) + 0.5$
- Effect: Adjusts the difference between light and dark values

### Highlights
- Range: [-100, +100]
- Implementation: For luminance > 0.5:
  $$
  RGB_{out} = RGB_{in} \times (1 + highlightsAdjust \times (luminance - 0.5))
  $$
  where $luminance = 0.299R + 0.587G + 0.114B$

### Shadows
- Range: [-100, +100]
- Implementation: For luminance < 0.5:
  $$
  RGB_{out} = RGB_{in} \times (1 + shadowsAdjust \times (0.5 - luminance))
  $$

### Whites
- Range: [-100, +100]
- Implementation: For luminance > 0.75:
  $$
  RGB_{out} = RGB_{in} \times (1 + whites \times 0.01 \times (luminance - 0.75))
  $$

### Blacks
- Range: [-100, +100]
- Implementation: For luminance < 0.25:
  $$
  RGB_{out} = RGB_{in} \times (1 + blacks \times 0.01 \times (0.25 - luminance))
  $$

## Color Controls

### Temperature
- Range: [-100, +100]
- Implementation: Shifts hue in HSL color space
- Effect: Adjusts blue-yellow balance
  $$
  hue_{out} = hue_{in} + temperature \times 0.0005
  $$

### Tint
- Range: [-100, +100]
- Implementation: Shifts hue in HSL color space
- Effect: Adjusts green-magenta balance
  $$
  hue_{out} = hue_{in} + tint \times 0.0005
  $$

### Vibrance
- Range: [-100, +100]
- Implementation: Selective saturation adjustment based on current saturation levels
- Effect: Increases saturation of less-saturated colors more than already-saturated colors

### Saturation
- Range: [-100, +100]
- Implementation: Multiplies saturation in HSL color space:
  $$
  saturation_{out} = saturation_{in} \times (1 + saturation \times 0.01)
  $$

## Technical Implementation Details

### Color Space Transformations

The shader performs color adjustments in both RGB and HSL color spaces. The conversion between RGB and HSL is implemented using the following algorithms:

#### RGB to HSL Conversion

The RGB to HSL conversion is performed using the following steps:

1. Find maximum and minimum RGB values:
   $$
   max = max(R, G, B)
   $$
   $$
   min = min(R, G, B)
   $$
   $$
   \Delta = max - min
   $$

2. Calculate Lightness:
   $$
   L = \frac{max + min}{2}
   $$

3. Calculate Saturation:
   $$
   S = \begin{cases}
   \frac{\Delta}{max + min} & \text{if } L < 0.5 \\
   \frac{\Delta}{2 - max - min} & \text{if } L \geq 0.5
   \end{cases}
   $$

4. Calculate Hue:
   $$
   H = \begin{cases}
   \frac{G - B}{\Delta} + 0 & \text{if } max = R \\
   \frac{B - R}{\Delta} + 2 & \text{if } max = G \\
   \frac{R - G}{\Delta} + 4 & \text{if } max = B
   \end{cases}
   $$
   $$
   H = \frac{H}{6}
   $$

### Performance Considerations

1. All adjustments are performed in a single shader pass to minimize GPU texture reads/writes
2. Uniform values are updated only when controls change
3. The preview curve is generated using a 256×1 pixel texture for efficiency

### Tone Curve Visualization

The tone curve visualization is generated by:
1. Creating a 256×1 gradient texture
2. Processing it through the same shader as the main image
3. Reading back the processed pixels
4. Plotting the resulting values using Recharts

## WebGL Context Management

The editor maintains three separate WebGL contexts:
- Original image preview
- Processed image preview
- Tone curve calculation

Each context is initialized with the same shader program but operates independently to prevent context conflicts.

## Order of Operations

The adjustments are applied in a specific order in the fragment shader to ensure consistent and predictable results:

1. **Raw Image Input**
   - Texture sampling: $color = texture2D(u_image, v_texCoord)$

2. **Exposure Adjustment**
   - Applied first to preserve the linear relationship with incoming light
   - $RGB_{raw} \rightarrow RGB_{exposure}$

3. **Contrast Adjustment**
   - Applied after exposure to maintain proper tonal distribution
   - $RGB_{exposure} \rightarrow RGB_{contrast}$

4. **Color Temperature and Tint**
   1. Convert to HSL
   2. Apply temperature adjustment (blue-yellow balance)
   3. Apply tint adjustment (green-magenta balance)
   4. Convert back to RGB

5. **Saturation and Vibrance**
   - Applied after temperature/tint to ensure proper color enhancement
   - Saturation is applied globally
   - Vibrance is applied selectively based on current saturation levels

6. **Tonal Range Adjustments**
   1. Calculate luminance
   2. Apply shadows adjustment (luminance < 0.5)
   3. Apply highlights adjustment (luminance > 0.5)
   4. Apply blacks adjustment (luminance < 0.25)
   5. Apply whites adjustment (luminance > 0.75)

7. **Final Clamping**
   - Ensure all values are within valid range: $RGB_{final} = clamp(RGB, 0.0, 1.0)$

### Rationale for Order

1. **Exposure First**:
   - Simulates the physical process of light capture
   - Provides the foundation for all subsequent adjustments

2. **Contrast Before Color**:
   - Ensures contrast adjustments work on the full luminance range
   - Prevents color shifts that could occur if applied after color adjustments

3. **Color Before Tonal Range**:
   - Allows color adjustments to work with the full dynamic range
   - Prevents color shifts that could occur from subsequent luminance changes

4. **Tonal Range Last**:
   - Fine-tunes the final image appearance
   - Provides precise control over specific brightness regions
   - Maintains color accuracy from previous adjustments

### Implementation Note

All operations are performed in a single shader pass for efficiency. The order is fixed in the shader code and cannot be modified at runtime. This ensures consistent results and optimal performance.
